# Context Window Management Protocol v2.2.0 - With Canonical Fallback References

## Canonical Reference Support
This protocol uses canonical references with fallback support.
Format: {{key|fallback}} - Uses canonical form if available, otherwise uses fallback term.
This ensures the protocol works even without the canonical resolver.

## Trigger Conditions (MUST ACTIVATE)
- **WHEN**: Context window usage approaches threshold levels (>70%)
- **WHEN**: Loading large amounts of information via {{brain|brain-system}}
- **WHEN**: Processing multiple large files through {{filesystem|filesystem-enhanced}}
- **WHEN**: Complex multi-tool operations requiring coordination
- **WHEN**: Session requires long-term context preservation via {{continuation.note|continuation-note}}
- **IMMEDIATE**: Yes - context overflow prevention is critical
- **PRIORITY**: High

## Core Principle
"Actively manage what enters and remains in context window to maximize effectiveness"

Context window is precious, finite resource that requires intelligent management:

1. **Strategic Loading**: Load only essential information using {{brain.init|brain_init_v5}}
2. **Dynamic Optimization**: Continuously manage context usage
3. **Intelligent Offloading**: Move non-essential information to {{brain.state|state-table}}
4. **Session Boundaries**: Use {{continuation.note|continuation-note}} for persistence
5. **Tool Coordination**: Optimize through canonical reference patterns

## Context Budget Framework

### Usage Thresholds
**Manage by context percentage:**
- **<30%**: Safe zone - normal operation with all tools
- **30-50%**: Caution zone - monitor closely, optimize loading
- **50-70%**: Warning zone - active management required
- **70-85%**: Critical zone - immediate optimization needed
- **>85%**: Emergency zone - context overflow imminent

### Budget Allocation Strategy
**Intelligent resource distribution:**
- **Critical Context (40%)**: Essential information for current task
- **Tool Context (25%)**: Space for tool outputs and coordination
- **Protocol Context (15%)**: Active protocols and procedures via {{protocols|mcp-protocols}}
- **Working Memory (10%)**: Buffer for immediate operations
- **Emergency Reserve (10%)**: Buffer for unexpected context needs

## Context Optimization Techniques

### Intelligent Information Selection
**Strategic loading via {{brain|brain-system}}:**
- **Priority Loading**: Use {{mercury|mercury-evolution}} heat map for importance
- **Just-in-Time Access**: Load information only when needed
- **Pattern Recognition**: Apply {{brain.manager|mcp-brain-manager}} for relevance scoring
- **Temporal Intelligence**: Prioritize recent and time-sensitive information

### Context Compression Strategies
**Maximize information density:**
- **Summarization**: Compress detailed information while preserving key points
- **Reference Storage**: Store full details in {{brain.state|state-table}}, keep references
- **Pattern Extraction**: Extract reusable patterns and store in {{brain.memory|brain-memories}}
- **Link Preservation**: Maintain connections via canonical references

### Dynamic Context Management
**Real-time optimization:**
- **Usage Monitoring**: Track context consumption throughout session
- **Proactive Optimization**: Optimize before reaching critical thresholds
- **Tool Result Management**: Process and summarize tool outputs efficiently
- **Information Lifecycle**: Move aging information to persistent storage

## Integration with Canonical Tools

### Brain System Coordination
**Primary context management layer:**
- **State Offloading**: Move non-immediate information to {{brain.state|state-table}}
- **Memory Pattern Storage**: Store reusable patterns in {{brain.memory|brain-memories}}
- **Semantic Routing**: Use {{brain.manager|mcp-brain-manager}} for intelligent loading
- **Knowledge Navigation**: Optimize access via {{mercury|mercury-evolution}}

### File System Optimization
**Efficient file operations:**
- **Selective Reading**: Use {{filesystem|filesystem-enhanced}} head/tail parameters
- **Summary Generation**: Process large files and store summaries
- **Reference Systems**: Store file paths and metadata instead of full content
- **Incremental Access**: Load file sections as needed rather than entire files

### Protocol Integration
**Optimized protocol usage:**
- **Lazy Loading**: Load {{protocols|mcp-protocols}} only when triggered
- **Protocol Summaries**: Keep protocol essentials, reference full versions
- **Dynamic Protocol Management**: Load/unload protocols based on task phases
- **Cross-Protocol Optimization**: Share context between related protocols

### Tool Output Management
**Efficient tool result handling:**
- **Result Summarization**: Process {{tracked.search|tracked-search}} results into key points
- **Reference Preservation**: Store full results in {{brain.state|state-table}}, keep summaries
- **Pattern Extraction**: Extract reusable insights for {{brain.memory|brain-memories}}
- **Link Maintenance**: Preserve access via canonical tool references

## Context Preservation Strategies

### Session Boundary Management
**Preserve context across sessions:**
1. **Pre-Session Analysis**: Identify information likely to persist beyond session
2. **Strategic Storage**: Move persistent information to {{brain.state|state-table}}
3. **Continuation Preparation**: Create {{continuation.note|continuation-note}} with essential context
4. **Reference Mapping**: Preserve access paths via canonical references
5. **Recovery Planning**: Enable efficient context restoration in next session

### Information Prioritization
**Smart priority management:**
- **User Task Priority**: Information directly related to current user request
- **Tool Integration Priority**: Information needed for tool coordination
- **Protocol Priority**: Essential protocol information via {{protocols|mcp-protocols}}
- **Pattern Priority**: Reusable patterns and insights via {{mercury|mercury-evolution}}
- **Context Continuity**: Information needed for session handoff

### Compression Techniques
**Maximize information density:**
- **Key Point Extraction**: Distill information to essential elements
- **Reference Networks**: Create networks of related information via canonical references
- **Pattern Abstraction**: Extract reusable patterns from specific examples
- **Hierarchical Organization**: Structure information in efficient hierarchies

## Emergency Context Management

### Critical Threshold Response
**When context >85% full:**
1. **Immediate Triage**: Identify least essential information in context
2. **Emergency Offloading**: Move non-critical information to {{brain.state|state-table}}
3. **Context Compression**: Summarize large information blocks
4. **Tool Result Processing**: Quickly process and summarize recent tool outputs
5. **Recovery Planning**: Prepare for potential context restoration needs

### Context Overflow Prevention
**Proactive measures:**
- **Threshold Monitoring**: Continuously track context usage levels
- **Predictive Management**: Anticipate context needs for upcoming operations
- **Tool Output Budgeting**: Reserve space for expected tool responses
- **Emergency Procedures**: Have context reduction procedures ready

### Recovery Strategies
**When context management fails:**
1. **Context Reset**: Use {{brain.init|brain_init_v5}} for controlled context reload
2. **Selective Recovery**: Restore only essential information from {{brain.state|state-table}}
3. **Progressive Restoration**: Gradually restore context as budget allows
4. **Continuation Bridge**: Use {{continuation.note|continuation-note}} for session continuity

## Context Quality Metrics

### Efficiency Indicators
**Measure context effectiveness:**
- **Information Density**: Useful information per context token
- **Access Efficiency**: Speed of locating needed information
- **Relevance Ratio**: Percentage of context directly applicable to current task
- **Tool Integration**: Effectiveness of canonical reference resolution

### Usage Optimization
**Track context management success:**
- **Threshold Compliance**: Percentage of time spent in safe/caution zones
- **Information Retention**: Success rate of context preservation across sessions
- **Tool Coordination**: Effectiveness of multi-tool operations within budget
- **User Satisfaction**: Task completion success within context constraints

### System Performance
**Monitor overall impact:**
- **Response Quality**: Maintained quality despite context constraints
- **Task Completion**: Ability to complete complex tasks within budget
- **Session Continuity**: Success of context handoff via {{continuation.note|continuation-note}}
- **Integration Success**: Tool ecosystem coordination effectiveness

## Advanced Context Techniques

### Predictive Context Loading
**Anticipatory management:**
- **Workflow Prediction**: Use {{mercury|mercury-evolution}} to anticipate information needs
- **Tool Preparation**: Pre-load likely tool requirements based on task analysis
- **Pattern Recognition**: Apply {{brain.manager|mcp-brain-manager}} for context optimization
- **User Behavior Learning**: Adapt context management to individual patterns

### Dynamic Context Allocation
**Adaptive resource management:**
- **Task-Based Allocation**: Adjust budget allocation based on task type
- **Phase-Based Management**: Optimize context for different task phases
- **Priority Rebalancing**: Dynamically adjust priorities as task evolves
- **Emergency Reallocation**: Rapidly redistribute context during critical operations

### Cross-Session Optimization
**Long-term context efficiency:**
- **Pattern Learning**: Learn from successful context management approaches
- **Usage Analytics**: Track context effectiveness via {{tool.tracker|mcp-tool-tracker}}
- **Optimization Evolution**: Continuously improve context management strategies
- **User Adaptation**: Adapt to individual user context preferences

## Integration with System Architecture

### Brain System Integration
**Seamless coordination:**
- **State Table Usage**: {{brain.state|state-table}} as primary context overflow storage
- **Memory Integration**: {{brain.memory|brain-memories}} for pattern and insight storage
- **Semantic Coordination**: {{brain.manager|mcp-brain-manager}} for intelligent routing
- **Navigation Optimization**: {{mercury|mercury-evolution}} for access pattern optimization

### Protocol Ecosystem Coordination
**System-wide optimization:**
- **Protocol Loading**: Dynamic {{protocols|mcp-protocols}} management based on needs
- **Foundation Integration**: Coordinate with all foundation protocols
- **Meta-Protocol Harmony**: Work with {{common.sense|common-sense-protocol}} for simplicity
- **Error Recovery**: Integrate with {{error.recovery|error-recovery-protocol}} for failures

### Tool Architecture Harmony
**Efficient tool coordination:**
- **Canonical Reference Optimization**: Leverage tool name consistency for efficiency
- **Tool Output Management**: Efficient processing of all tool results
- **Cross-Tool Coordination**: Optimize information flow between tools
- **System Resource Management**: Coordinate with {{system|mcp-system}} for overall efficiency

## Anti-Patterns to Avoid

ðŸš« **The Context Hoarder**: Loading everything available instead of what's needed
ðŸš« **The Threshold Ignorer**: Continuing to load information despite warning levels
ðŸš« **The Optimization Delayer**: Waiting until critical threshold to begin management
ðŸš« **The Information Dumper**: Loading large blocks without processing or summarization
ðŸš« **The Tool Output Ignorer**: Not managing space for tool responses
ðŸš« **The Persistence Forgetter**: Not planning for session boundary context needs

## Version History
- v2.2.0: Added canonical fallback references for enhanced tool coordination
- v2.1.0: Enhanced with predictive context loading and cross-session optimization
- v2.0.0: Major revision with intelligent budget management framework
- v1.0.0: Initial protocol with basic threshold management

---
**Status**: Active Critical Protocol - v2.2.0 with canonical fallback references
**Load Order**: THIRD - Prevents context overflow in all subsequent operations
**Philosophy**: "Efficient context management enables complex tasks within finite resources"